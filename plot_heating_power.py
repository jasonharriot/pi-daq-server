import mysql.connector
import time
import configparser
import datetime
import zoneinfo
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation
import utils
from scipy.signal import savgol_filter

if __name__ == '__main__':
    cfg = configparser.ConfigParser()
    cfg.read('config_client.ini')   #Read sensitive parameters from the configuration file.

    mysql_config = cfg['mysql']

    db = mysql.connector.connect(
        host=mysql_config['host'],
        user=mysql_config['user'],
        password=mysql_config['password'],
        database=mysql_config['database']
        )

    start_date_str = '2025-05-23 15:40:00' #UTC start date/time.
    end_date_str = '2025-05-28 20:47:00' #UTC end date/time.

    #start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d %H:%M:%S').replace(tzinfo=datetime.timezone.utc)
    #end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d %H:%M:%S').replace(tzinfo=datetime.timezone.utc)

    #df = utils.fetch_df_date(db, start_date, 0) #Grab the latest data.  Set number of points to zero to fetch all.
    #df = utils.fetch_df_date_date(db, start_date, end_date, 1000) #Grab the latest N datapoints. Actual number of rows returned is approximate.

    timespan_hours = 96 #Hours. This variable used to insert a nice label in the plot title.
    df = utils.fetch_df_hours(db, timespan_hours, 1000) #Grab n datapoints across the past t hours.

    #Calculate reactor energy

    liquid_density = 1 #kg/L
    liquid_specific_heat = 4184 #J-kg^-1-K^-1
    #constant_heater_power = 2677.5  #Ideal number of watts generated by one water heater.

    df['E1'] = df['V1_real']*(df['T1_real']+273.15)*liquid_specific_heat*liquid_density #Energy of the reactor, in joules

    #Calculate reactor net power

    energy_diff = df['E1'].diff().rolling(10).mean()   #Apply some smoothing (rolling average) to this diff series. It will be noisy.
    #energy_diff = savgol_filter(df['E1'].diff(), 30, 3)    #Alternate smoothing technique


    time_diff = [x.seconds for x in df['timestamp_local'].diff()]  #Get the number of seconds

    df['P1'] = energy_diff/time_diff    #Power of the reactor, in Watts

    print(df)

    #Plot the data

    fig, ax1 = plt.subplots(layout='constrained')    #Get the figure object and primary axes for later use. Use the constrained layout option for better looks.

    fig.suptitle(f'Reactor process values\n{timespan_hours} hours')
    
    ax2 = ax1.twinx()   #Secondary y-axis object
    #ax3 = ax1.twinx()   #Third y-axis object
    ax4 = ax1.twinx()   #Fourth y-axis object

    ax1.tick_params(axis='x', labelrotation=45) #Make the x-axis labels rotated so they fit better

    ax1.set_xlabel('Date')
    ax1.set_ylabel('Temperature (Â°C)')
    ax2.set_ylabel('Volume (L)')
    #ax3.set_ylabel('Energy (GJ)')
    ax4.set_ylabel('Power (kW)')

    ax2.yaxis.set_major_formatter('{x:.0f}')    #Display numbers on the secondary y-axis with no decimal point.
    ax2.set_ylim(300, 800)  #Set the limits of the secondary y-axis. Volume in Liters.

    #ax3.spines.right.set_position(('outward', 50))    #Gigajoules
    #ax3.yaxis.set_major_formatter('{x:.3f}')
    #ax3.set_ylim(0, 3)

    ax4.spines.right.set_position(('outward', 50))    #Kilowatts. Move the spines N points to the right. This adjustment is in real units (points), not a coefficient of the figure size. This is prefered when resizing the figure window.
    ax4.yaxis.set_major_formatter('{x:.1f}')
    ax4.set_ylim(-3, 3) #Y-axis limits, in kilowatts

    #Plot each set of data. Grab element [0] of the return value, which we will use to generate labels. Don't need the other values.
    graph_P1 = ax4.plot(df['timestamp_local'], df['P1']*1e-3, color='green', label='P1')[0]  #Plot power in kilowatts.
    #graph_E1 = ax3.plot(df['timestamp_local'], df['E1']*1e-9, color='pink', label='E1')[0]   #Plot energy in gigajoules.
    graph_V1 = ax2.plot(df['timestamp_local'], df['V1_real'], color='blue', label='V1')[0]   #Plot V1 on the secondary y-axis
    graph_T2 = ax1.plot(df['timestamp_local'], df['T2_real'], color='orange', label='T2')[0] #Plot T2
    graph_T1 = ax1.plot(df['timestamp_local'], df['T1_real'], color='red', label='T1')[0]    #Plot T1.
    
    graphs = [graph_P1, graph_V1, graph_T2, graph_T1] #Create a list of objects returned from the plots we have invoked.

    labels = [graph.get_label() for graph in graphs]    #Greate a list of labels where each label is generated from the list of graphs. While tedious, this is the only way to have one legend with multiple labels from multiple axes.

    ax1.legend(graphs, labels, loc=0)   #Create the legend from the list of graphs and list of labels. The legend technically belongs only to ax1, but it will contain entries for all plots on all axes, because we have specified them explicitly in those lists.

    plt.show()